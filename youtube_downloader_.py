# -*- coding: utf-8 -*-
"""YouTube Downloader .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l8mv7Y5TOndpqp0u3_f9OKYU-0uzg2Cc
"""

pip install gradio yt-dlp pydub whisper transformers torch python-dotenv google-genai

!pip install gradio pytube google-cloud-speech google-generativeai moviepy

"""
YouTube -> Download -> Upload audio to GCS -> Google Speech-to-Text (long_running_recognize)
-> Gemini summary -> Gradio UI with video preview.

Make sure:
- GOOGLE_APPLICATION_CREDENTIALS points to a service account JSON with Storage+Speech access.
- GEMINI_API_KEY set for the google-genai client, or adapt client init to use Vertex auth.
- ffmpeg is installed.
"""

import os
import tempfile
import shutil
import time
from pathlib import Path

import gradio as gr
import yt_dlp
from pydub import AudioSegment

# Google Cloud clients
from google.cloud import storage
# Corrected import for Speech-to-Text client
from google.cloud.speech_v1p1beta1 import SpeechClient # Corrected import
from google.cloud.speech_v1p1beta1 import RecognitionConfig, RecognitionAudio # Import necessary classes


# Gemini/GenAI client (python-genai)
from google import genai

# ----------------------------
# Configuration
# ----------------------------
DOWNLOADS_DIR = Path("downloads")
DOWNLOADS_DIR.mkdir(exist_ok=True)
GCS_BUCKET = os.environ.get("GCS_BUCKET_NAME")  # optional: set a default bucket name in env
GEMINI_MODEL = os.environ.get("GEMINI_MODEL", "gemini-2.5-flash")
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")  # required unless you use Vertex auth
# ----------------------------

# Initialize cloud clients (will use GOOGLE_APPLICATION_CREDENTIALS)
def get_storage_client():
    return storage.Client()

def get_speech_client():
    # Use the SpeechClient from the corrected import
    return SpeechClient() # Use the imported SpeechClient class

def get_genai_client(api_key=None):
    if api_key:
        return genai.Client(api_key=api_key)
    # fallback, genai.Client() may pick up env or ADC depending on your environment
    return genai.Client()

# ----------------------------
# Helpers
# ----------------------------
def download_video_with_ytdlp(url: str, download_video: bool = True, max_height: int = 720):
    tmpdir = tempfile.mkdtemp(prefix="ytdl_")
    outtmpl = str(Path(tmpdir) / "%(title)s.%(ext)s")
    if download_video:
        fmt = f"bestvideo[height<={max_height}]+bestaudio/best"
        opts = {"format": fmt, "outtmpl": outtmpl, "merge_output_format": "mp4", "quiet": True}
    else:
        opts = {
            "format": "bestaudio/best",
            "outtmpl": outtmpl,
            "quiet": True,
            "postprocessors": [
                {"key": "FFmpegExtractAudio", "preferredcodec": "mp3", "preferredquality": "192"}
            ],
        }
    with yt_dlp.YoutubeDL(opts) as ydl:
        info = ydl.extract_info(url, download=True)
        filename = ydl.prepare_filename(info)
        if not download_video:
            filename = filename.rsplit(".", 1)[0] + ".mp3"
    title = info.get("title", "video")
    return filename, title, tmpdir

def extract_audio_to_wav(input_path: str, out_wav_path: str):
    """
    pydub will use ffmpeg to convert; speech-to-text likes FLAC or LINEAR16 WAV.
    We'll write WAV (16k/16-bit) for broad compatibility.
    """
    audio = AudioSegment.from_file(input_path)
    # ensure sample rate 16000 and export as wav (PCM 16)
    audio = audio.set_frame_rate(16000).set_sample_width(2).set_channels(1)
    audio.export(out_wav_path, format="wav")
    return out_wav_path

def upload_file_to_gcs(bucket_name: str, source_file_path: str, dest_blob_name: str):
    client = get_storage_client()
    bucket = client.bucket(bucket_name)
    blob = bucket.blob(dest_blob_name)
    blob.upload_from_filename(source_file_path)
    # Return gs:// URI
    return f"gs://{bucket_name}/{dest_blob_name}"

def transcribe_gcs_long_running(gcs_uri: str, language_code="en-US"):
    """
    Uses long_running_recognize for large files.
    Returns concatenated transcript text.
    """
    client = get_speech_client()

    audio = RecognitionAudio(uri=gcs_uri) # Use RecognitionAudio class
    config = RecognitionConfig( # Use RecognitionConfig class
        language_code=language_code,
        # Use the correct encoding for LINEAR16
        encoding=RecognitionConfig.AudioEncoding.LINEAR16,
        sample_rate_hertz=16000,
        enable_automatic_punctuation=True,
        enable_speaker_diarization=False,
        # you can set model="latest_long" or "video" depending on your project & pricing
        model="latest_long",
    )
    operation = client.long_running_recognize(config=config, audio=audio)
    # wait for operation to complete (blocking)
    response = operation.result(timeout=3600)  # adjust timeout as needed
    # concatenate results
    transcripts = []
    for result in response.results:
        transcripts.append(result.alternatives[0].transcript)
    full_transcript = " ".join(transcripts).strip()
    return full_transcript

def summarize_with_gemini(genai_client, model_name: str, transcript: str, max_chars: int = 1200):
    """
    Use genai client to generate a structured summary.
    We'll call the model's generate_content equivalent via client.models.generate_content(...)
    The python-genai docs show client.models.generate_content returning an object with .text property.
    """
    prompt = (
        "You are a helpful assistant. Given the following transcript from a video, produce:\n"
        "1) One-sentence summary.\n"
        "2) 4 concise bullet points of the main ideas.\n"
        "3) 3 short tags (comma-separated).\n\n"
        "Transcript:\n"
        f"{transcript}\n\nSummary:"
    )
    # call the model
    resp = genai_client.models.generate_content(model=model_name, contents=prompt)
    # try to extract text
    text = getattr(resp, "text", None)
    if text is None:
        text = str(resp)
    if len(text) > max_chars:
        text = text[:max_chars].rstrip() + "..."
    return text

# ----------------------------
# Main pipeline (for Gradio)
# ----------------------------
def yt_download_transcribe_summarize(
    url: str,
    mode: str,                 # "Video (MP4)" or "Audio (MP3)"
    gcs_bucket: str,
    gemini_model: str,
    gemini_api_key: str | None,
    language_code: str = "en-US",
    progress=gr.Progress()
):
    """
    Returns: (preview_path, title, transcript, summary, status_message)
    """
    try:
        if not url:
            return None, "", "", "", "‚ùå No URL provided."

        progress(0, desc="Downloading video/audio...")
        download_video_flag = mode.startswith("Video")
        local_path, title, tmpdir = download_video_with_ytdlp(url, download_video=download_video_flag)

        # preview_path: copy to downloads folder so Gradio can serve it
        safe_name = title.replace("/", "_").replace("\\", "_")[:180]
        preview_ext = Path(local_path).suffix or (".mp3" if not download_video_flag else ".mp4")
        preview_target = DOWNLOADS_DIR / f"{safe_name}{preview_ext}"
        shutil.copy(local_path, preview_target)

        progress(20, desc="Preparing audio for transcription...")
        # produce a WAV file suitable for Speech-to-Text
        wav_path = os.path.join(tmpdir, "audio_for_transcribe.wav")
        if download_video_flag:
            extract_audio_to_wav(local_path, wav_path)
        else:
            # if the downloaded file is mp3, convert to wav
            extract_audio_to_wav(local_path, wav_path)

        progress(40, desc="Uploading audio to Google Cloud Storage...")
        bucket_name = gcs_bucket or GCS_BUCKET
        if not bucket_name:
            return str(preview_target), title, "", "", "‚ùå GCS bucket name not provided. Set GCS_BUCKET_NAME env var or provide in UI."

        dest_blob_name = f"yt_audio_uploads/{safe_name}_{int(time.time())}.wav"
        gcs_uri = upload_file_to_gcs(bucket_name, wav_path, dest_blob_name)

        progress(60, desc="Transcribing audio (this can take a while)...")
        transcript = transcribe_gcs_long_running(gcs_uri, language_code=language_code)
        if not transcript.strip():
            transcript = "‚ö†Ô∏è Transcription returned empty text."

        progress(85, desc="Summarizing with Gemini...")
        genai_client = get_genai_client(api_key=gemini_api_key or GEMINI_API_KEY)
        summary = summarize_with_gemini(genai_client, gemini_model, transcript)

        progress(100, desc="Finished.")
        # cleanup tmpdir but keep preview copy
        try:
            shutil.rmtree(tmpdir, ignore_errors=True)
        except Exception:
            pass

        return str(preview_target), title, transcript, summary, "‚úÖ Success"

    except Exception as e:
        return None, "", "", "", f"‚ùå Fatal error: {e}"

# ----------------------------
# Gradio UI
# ----------------------------
def build_ui():
    with gr.Blocks(title="YouTube ‚Üí Download ‚Üí Transcribe (GCloud) ‚Üí Gemini Summary") as demo:
        gr.Markdown("# üé• YouTube Downloader + GCloud STT + Gemini Summary")

        with gr.Row():
            url_in = gr.Textbox(label="YouTube URL", placeholder="https://www.youtube.com/watch?v=...")
            mode = gr.Radio(choices=["Video (MP4)", "Audio (MP3)"], value="Video (MP4)", label="Download Mode")
        with gr.Row():
            gcs_bucket_in = gr.Textbox(label="GCS Bucket name", placeholder="Your GCS bucket (or set GCS_BUCKET_NAME env var)", value=os.environ.get("GCS_BUCKET_NAME",""))
            gemini_model_in = gr.Textbox(label="Gemini model", value=GEMINI_MODEL)
            gemini_key_in = gr.Textbox(label="Gemini API Key (optional)", placeholder="Leave blank to use GEMINI_API_KEY env var", type="password")
        with gr.Row():
            run_btn = gr.Button("Download ‚Üí Transcribe ‚Üí Summarize")
            reset_btn = gr.Button("Reset")

        preview = gr.Video(label="Downloaded Preview (click play)")
        title_out = gr.Textbox(label="Title")
        transcript_out = gr.Textbox(label="Transcript", lines=12)
        summary_out = gr.Textbox(label="Gemini Summary", lines=8)
        status_out = gr.Textbox(label="Status", lines=2)

        run_btn.click(
            fn=yt_download_transcribe_summarize,
            inputs=[url_in, mode, gcs_bucket_in, gemini_model_in, gemini_key_in],
            outputs=[preview, title_out, transcript_out, summary_out, status_out]
        )

        reset_btn.click(lambda: (None, "", "", "", ""), [], [preview, title_out, transcript_out, summary_out, status_out])

        gr.Markdown(
            """
            **Notes**
            - Set `GOOGLE_APPLICATION_CREDENTIALS` to your service account JSON.
            - Ensure the service account has Storage Object Creator and Speech-to-Text permissions.
            - `GCS_BUCKET_NAME` may be set as an environment variable, or provide it in the UI.
            - Long files can take minutes to transcribe ‚Äî be patient.
            - Gemini calls cost credits; watch usage and quotas.
            """
        )
    return demo

if __name__ == "__main__":
    ui = build_ui()
    # Change the server_port to a different value
    ui.launch(server_port=7861)

